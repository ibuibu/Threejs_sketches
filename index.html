<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/105/three.min.js"></script>
  <script>

		var video,texture;

		navigator.getUserMedia(
			// カメラを使用して、マイクを使用しない場合
			{ video: true, audio: false },
			// localMediaStream（カメラ映像のストリームデータが含まれる）が取得できた場合
			function( localMediaStream ) {
				// ここにlocalMediaStreamを取得できたときの処理を記述
				video = document.createElement( 'video' );
				// URLオブジェクトを作成して、videoエレメントのsrcに設定
				video.srcObject = localMediaStream;
				// 動画の再生
				video.play();
			// 動画テクスチャ作成
			texture = new THREE.VideoTexture( video );
			// 1テクセルが1ピクセルより大きな範囲をカバーするときのテクスチャサンプリング方法の指定
			texture.magFilter = THREE.LinearFilter;
			// 1テクセルが1ピクセルより小さな範囲をカバーするときのテクスチャサンプリング方法の指定
			texture.minFilter = THREE.LinearFilter;
			// 動画テクスチャフォーマットの指定
			texture.format = THREE.RGBFormat;
			},
			// localMediaStreamが取得できなかった場合
			function( err ) {
					console.log( err );
			}
		);

    // ページの読み込みを待つ
		window.addEventListener('load',
		()=>{setTimeout(init,3000)});

    function init() {

      // サイズを指定
      const width = 480;
      const height = 270;

      // レンダラーを作成
      const renderer = new THREE.WebGLRenderer({
        canvas: document.querySelector('#myCanvas')
      });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(width, height);

      // シーンを作成
      const scene = new THREE.Scene();

      // カメラを作成
      const camera = new THREE.PerspectiveCamera(45, width / height);
      camera.position.set(0, 0, +1000);



      // 箱を作成
      const geometry = new THREE.BoxGeometry(400, 400, 400);
      const material = new THREE.MeshStandardMaterial({
				map: texture
			});
      const box = new THREE.Mesh(geometry, material);
			scene.add(box);

			        // 平行光源
        const directionalLight = new THREE.DirectionalLight(0xffffff);
        directionalLight.position.set(1, 1, 1);
        // シーンに追加
        scene.add(directionalLight);


      tick();

      // 毎フレーム時に実行されるループイベントです
      function tick() {
        box.rotation.y += 0.01;
        renderer.render(scene, camera); // レンダリング

        requestAnimationFrame(tick);
      }
    }
  </script>
</head>
<body>
  <canvas id="myCanvas"></canvas>
</body>
</html>